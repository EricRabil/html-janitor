{"version":3,"file":"html-janitor.min.js","mappings":"CAAA,SAAAA,EAAAC,GACA,kBAAAC,SAAAA,OAAAC,IACAD,OAAA,eAAAD,GACA,gBAAAG,SACAC,OAAAD,QAAAH,IAEAD,EAAAM,YAAAL,KAEAM,KAAA,WAMA,QAAAD,GAAAE,GAEA,GAAAC,GAAAD,EAAA,KACAE,EAAAC,OAAAC,KAAAH,GAEAI,EAAAH,EACAI,IAAA,SAAAC,GAAA,aAAAN,GAAAM,KACAC,MAAA,SAAAC,GAAA,MAAA,WAAAA,GAAA,YAAAA,GAEA,KAAAJ,EACA,KAAA,IAAAK,OAAA,gCAGAX,MAAAC,OAAAA,EAKA,QAAAW,GAAAC,GACA,MAAA,KAAAC,EAAAC,QAAAF,EAAAG,UAIA,QAAAC,GAAAJ,GACA,MAAA,KAAAK,EAAAH,QAAAF,EAAAG,UAyGA,QAAAG,GAAAN,GACA,MAAAO,UAAAD,iBAAAN,EACAQ,WAAAC,UAAAD,WAAAE,aAAAF,WAAAG,aACA,MAAA,GAnHA,GAAAV,IAAA,IAAA,KAAA,KAAA,KAAA,MAAA,KAAA,KAAA,KAAA,KAAA,KAAA,KAAA,OAKAI,GAAA,IAAA,IAAA,SAAA,IAAA,KAAA,MAAA,MAAA,IAAA,SAiHA,OA5GAnB,GAAA0B,UAAAC,MAAA,SAAAC,GACA,GAAAC,GAAAR,SAAAS,cAAA,MAKA,OAJAD,GAAAE,UAAAH,EAEA3B,KAAA+B,UAAAH,GAEAA,EAAAE,WAGA/B,EAAA0B,UAAAM,UAAA,SAAAC,GACA,GAAAC,GAAAd,EAAAa,GACAnB,EAAAoB,EAAAC,YACA,IAAArB,EAEA,EAAA,CACA,GAAAG,GAAAH,EAAAG,SAAAmB,cACAC,EAAApC,KAAAC,OAAAE,KAAAa,EAGA,KAAAH,EAAAwB,WAIA,GAAAxB,EAAAyB,WAAAC,KAAAC,UAAA,CAkBA,GAAA3B,EAAAyB,WAAAC,KAAAE,aAAA,CACAT,EAAAU,YAAA7B,GACAb,KAAA+B,UAAAC,EACA,OAGA,GACAW,GADAC,EAAA3B,EAAAJ,EAEA+B,KACAD,EAAAE,MAAApB,UAAAqB,KAAAC,KAAAlC,EAAAmC,WAAApC,GAGA,IAAAqC,GAAAL,GAAAD,EAIAO,IAAAlB,EAAAA,WACAmB,EACAvC,EAAAoB,IACApB,EAAAC,IACAqC,CAIA,IAAAE,SAAApD,KAAAC,OAAAE,KAAAa,IAAAiC,IAAAjD,KAAAC,OAAAoD,yBAAAF,EAAA,CAEA,GAAA,WAAAtC,EAAAG,UAAA,UAAAH,EAAAG,SACA,KAAAH,EAAAmC,WAAAM,OAAA,GACAtB,EAAAuB,aAAA1C,EAAAmC,WAAA,GAAAnC,EAGAmB,GAAAU,YAAA7B,GAEAb,KAAA+B,UAAAC,EACA,OAIA,IAAA,GAAAwB,GAAA,EAAAA,EAAA3C,EAAA4C,WAAAH,OAAAE,GAAA,EAAA,CACA,GAAAE,GAAA7C,EAAA4C,WAAAD,GACAG,EAAAD,EAAAE,KAAAzB,cAGA0B,EAAAzB,EAAAuB,IAAAvB,KAAA,EACA0B,GAAAD,EACAE,EAAAF,KAAA,GAAAH,EAAAM,QAAAH,GACAC,GAAAC,KACAlD,EAAAoD,gBAAAP,EAAAE,MAEAJ,GAAA,GAKAxD,KAAA+B,UAAAlB,GAGAA,EAAAwB,YAAA,MArEA,IAAA,KAAAxB,EAAAqD,KAAAC,SACAtD,EAAAuD,wBAAAxD,EAAAC,EAAAuD,yBACAvD,EAAAwD,oBAAAzD,EAAAC,EAAAwD,qBAAA,CACArC,EAAAU,YAAA7B,GACAb,KAAA+B,UAAAC,EACA,cAiEAnB,EAAAoB,EAAAqC,gBASAvE","sources":["../src/html-janitor.js"],"sourcesContent":["(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define('html-janitor', factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.HTMLJanitor = factory();\n  }\n}(this, function () {\n\n  /**\n   * @param {Object} config.tags Dictionary of allowed tags.\n   * @param {boolean} config.keepNestedBlockElements Default false.\n   */\n  function HTMLJanitor(config) {\n\n    var tagDefinitions = config['tags'];\n    var tags = Object.keys(tagDefinitions);\n\n    var validConfigValues = tags\n      .map(function(k) { return typeof tagDefinitions[k]; })\n      .every(function(type) { return type === 'object' || type === 'boolean'; });\n\n    if(!validConfigValues) {\n      throw new Error(\"The configuration was invalid\");\n    }\n\n    this.config = config;\n  }\n\n  // TODO: not exhaustive?\n  var blockElementNames = ['P', 'LI', 'TD', 'TH', 'DIV', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'PRE'];\n  function isBlockElement(node) {\n    return blockElementNames.indexOf(node.nodeName) !== -1;\n  }\n\n  var inlineElementNames = ['A', 'B', 'STRONG', 'I', 'EM', 'SUB', 'SUP', 'U', 'STRIKE'];\n  function isInlineElement(node) {\n    return inlineElementNames.indexOf(node.nodeName) !== -1;\n  }\n\n  HTMLJanitor.prototype.clean = function (html) {\n    var sandbox = document.createElement('div');\n    sandbox.innerHTML = html;\n\n    this._sanitize(sandbox);\n\n    return sandbox.innerHTML;\n  };\n\n  HTMLJanitor.prototype._sanitize = function (parentNode) {\n    var treeWalker = createTreeWalker(parentNode);\n    var node = treeWalker.firstChild();\n    if (!node) { return; }\n\n    do {\n      var nodeName = node.nodeName.toLowerCase();\n      var allowedAttrs = this.config.tags[nodeName];\n\n      // Ignore nodes that have already been sanitized\n      if (node._sanitized) {\n        continue;\n      }\n\n      if (node.nodeType === Node.TEXT_NODE) {\n        // If this text node is just whitespace and the previous or next element\n        // sibling is a block element, remove it\n        // N.B.: This heuristic could change. Very specific to a bug with\n        // `contenteditable` in Firefox: http://jsbin.com/EyuKase/1/edit?js,output\n        // FIXME: make this an option?\n        if (node.data.trim() === ''\n            && ((node.previousElementSibling && isBlockElement(node.previousElementSibling))\n                 || (node.nextElementSibling && isBlockElement(node.nextElementSibling)))) {\n          parentNode.removeChild(node);\n          this._sanitize(parentNode);\n          break;\n        } else {\n          continue;\n        }\n      }\n\n      // Remove all comments\n      if (node.nodeType === Node.COMMENT_NODE) {\n        parentNode.removeChild(node);\n        this._sanitize(parentNode);\n        break;\n      }\n\n      var isInline = isInlineElement(node);\n      var containsBlockElement;\n      if (isInline) {\n        containsBlockElement = Array.prototype.some.call(node.childNodes, isBlockElement);\n      }\n\n      var isInvalid = isInline && containsBlockElement;\n\n      // Block elements should not be nested (e.g. <li><p>...); if\n      // they are, we want to unwrap the inner block element.\n      var isNotTopContainer = !! parentNode.parentNode;\n      var isNestedBlockElement =\n            isBlockElement(parentNode) &&\n            isBlockElement(node) &&\n            isNotTopContainer;\n\n      // Drop tag entirely according to the whitelist *and* if the markup\n      // is invalid.\n      if (this.config.tags[nodeName] === undefined || isInvalid || (!this.config.keepNestedBlockElements && isNestedBlockElement)) {\n        // Do not keep the inner text of SCRIPT/STYLE elements.\n        if (! (node.nodeName === 'SCRIPT' || node.nodeName === 'STYLE')) {\n          while (node.childNodes.length > 0) {\n            parentNode.insertBefore(node.childNodes[0], node);\n          }\n        }\n        parentNode.removeChild(node);\n\n        this._sanitize(parentNode);\n        break;\n      }\n\n      // Sanitize attributes\n      for (var a = 0; a < node.attributes.length; a += 1) {\n        var attr = node.attributes[a];\n        var attrName = attr.name.toLowerCase();\n\n        // Allow attribute?\n        var allowedAttrValue = allowedAttrs[attrName] || allowedAttrs === true;\n        var notInAttrList = ! allowedAttrValue;\n        var valueNotAllowed = allowedAttrValue !== true && attr.value !== allowedAttrValue;\n        if (notInAttrList || valueNotAllowed) {\n          node.removeAttribute(attr.name);\n          // Shift the array to continue looping.\n          a = a - 1;\n        }\n      }\n\n      // Sanitize children\n      this._sanitize(node);\n\n      // Mark node as sanitized so it's ignored in future runs\n      node._sanitized = true;\n    } while ((node = treeWalker.nextSibling()));\n  };\n\n  function createTreeWalker(node) {\n    return document.createTreeWalker(node,\n                                     NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT,\n                                     null, false);\n  }\n\n  return HTMLJanitor;\n\n}));\n\n"],"names":["root","factory","define","amd","exports","module","HTMLJanitor","this","config","tagDefinitions","tags","Object","keys","validConfigValues","map","k","every","type","Error","isBlockElement","node","blockElementNames","indexOf","nodeName","isInlineElement","inlineElementNames","createTreeWalker","document","NodeFilter","SHOW_TEXT","SHOW_ELEMENT","SHOW_COMMENT","prototype","clean","html","sandbox","createElement","innerHTML","_sanitize","parentNode","treeWalker","firstChild","toLowerCase","allowedAttrs","_sanitized","nodeType","Node","TEXT_NODE","COMMENT_NODE","removeChild","containsBlockElement","isInline","Array","some","call","childNodes","isInvalid","isNotTopContainer","isNestedBlockElement","undefined","keepNestedBlockElements","length","insertBefore","a","attributes","attr","attrName","name","allowedAttrValue","notInAttrList","valueNotAllowed","value","removeAttribute","data","trim","previousElementSibling","nextElementSibling","nextSibling"]}